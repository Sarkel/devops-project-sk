// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const createTemperatureData = `-- name: CreateTemperatureData :many
insert into temp_checker.sensor_data(location_sensor_id, temperature, timestamp)
select unnest($1::int[]),
       unnest($2::float[]),
       unnest($3::timestamptz[])
returning sensor_data_id
`

type CreateTemperatureDataParams struct {
	LocationSensorIds []int32
	Temperatues       []float64
	Timestamps        []time.Time
}

func (q *Queries) CreateTemperatureData(ctx context.Context, arg CreateTemperatureDataParams) ([]int32, error) {
	rows, err := q.query(ctx, q.createTemperatureDataStmt, createTemperatureData, pq.Array(arg.LocationSensorIds), pq.Array(arg.Temperatues), pq.Array(arg.Timestamps))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var sensor_data_id int32
		if err := rows.Scan(&sensor_data_id); err != nil {
			return nil, err
		}
		items = append(items, sensor_data_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAPILocationSensors = `-- name: GetAPILocationSensors :many
select ls.location_sensor_id,
       ls.sensor_sid,
       l.location_sid,
       l.location_name,
       l.latitude,
       l.longitude,
       l.location_id
from temp_checker.location_sensor as ls
         join temp_checker.location as l on ls.location_id = l.location_id
where ls.type = 'api'
`

type GetAPILocationSensorsRow struct {
	LocationSensorID int32
	SensorSid        string
	LocationSid      string
	LocationName     string
	Latitude         float64
	Longitude        float64
	LocationID       int32
}

func (q *Queries) GetAPILocationSensors(ctx context.Context) ([]GetAPILocationSensorsRow, error) {
	rows, err := q.query(ctx, q.getAPILocationSensorsStmt, getAPILocationSensors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAPILocationSensorsRow
	for rows.Next() {
		var i GetAPILocationSensorsRow
		if err := rows.Scan(
			&i.LocationSensorID,
			&i.SensorSid,
			&i.LocationSid,
			&i.LocationName,
			&i.Latitude,
			&i.Longitude,
			&i.LocationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationSensorBySensorId = `-- name: GetLocationSensorBySensorId :one
select ls.location_sensor_id
from temp_checker.location_sensor as ls
         join temp_checker.location as l on ls.location_id = l.location_id
where ls.sensor_sid = $1
  and l.location_sid = $2
`

type GetLocationSensorBySensorIdParams struct {
	SensorSid   string
	LocationSid string
}

func (q *Queries) GetLocationSensorBySensorId(ctx context.Context, arg GetLocationSensorBySensorIdParams) (int32, error) {
	row := q.queryRow(ctx, q.getLocationSensorBySensorIdStmt, getLocationSensorBySensorId, arg.SensorSid, arg.LocationSid)
	var location_sensor_id int32
	err := row.Scan(&location_sensor_id)
	return location_sensor_id, err
}

const getLocations = `-- name: GetLocations :many
select location_sid, location_name
from temp_checker.location
`

type GetLocationsRow struct {
	LocationSid  string
	LocationName string
}

func (q *Queries) GetLocations(ctx context.Context) ([]GetLocationsRow, error) {
	rows, err := q.query(ctx, q.getLocationsStmt, getLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationsRow
	for rows.Next() {
		var i GetLocationsRow
		if err := rows.Scan(&i.LocationSid, &i.LocationName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSensorDataPoints = `-- name: GetSensorDataPoints :many
select ls.type,
       case when $1 is distinct from 'day' then sd.timestamp else sd.timestamp::date end as time_dim,
       round(avg(sd.temperature)::numeric, 1)::float                                                as avg_temperature
from temp_checker.sensor_data sd
         join temp_checker.location_sensor ls on sd.location_sensor_id = ls.location_sensor_id
         join temp_checker.location l on ls.location_id = l.location_id
where l.location_sid = $2
  and ls.type = any ($3::temp_checker.sensor_type[])
  and sd.timestamp between $4::timestamp and $5::timestamp
group by ls.type, time_dim
`

type GetSensorDataPointsParams struct {
	Aggregation   interface{}
	LocationSid   string
	Types         []TempCheckerSensorType
	StartDatetime time.Time
	EndDatetime   time.Time
}

type GetSensorDataPointsRow struct {
	Type           TempCheckerSensorType
	TimeDim        time.Time
	AvgTemperature float64
}

func (q *Queries) GetSensorDataPoints(ctx context.Context, arg GetSensorDataPointsParams) ([]GetSensorDataPointsRow, error) {
	rows, err := q.query(ctx, q.getSensorDataPointsStmt, getSensorDataPoints,
		arg.Aggregation,
		arg.LocationSid,
		pq.Array(arg.Types),
		arg.StartDatetime,
		arg.EndDatetime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSensorDataPointsRow
	for rows.Next() {
		var i GetSensorDataPointsRow
		if err := rows.Scan(&i.Type, &i.TimeDim, &i.AvgTemperature); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaySensorsSummary = `-- name: GetTodaySensorsSummary :many
select ls.type, now()::date as date, avg(sd.temperature) as avg_temperature
from temp_checker.sensor_data sd
         join temp_checker.location_sensor ls on sd.location_sensor_id = ls.location_sensor_id
         join temp_checker.location l on ls.location_id = l.location_id
where l.location_sid = $1
  and sd.timestamp::date = now()::date
group by ls.type
`

type GetTodaySensorsSummaryRow struct {
	Type           TempCheckerSensorType
	Date           time.Time
	AvgTemperature float64
}

func (q *Queries) GetTodaySensorsSummary(ctx context.Context, locationSid string) ([]GetTodaySensorsSummaryRow, error) {
	rows, err := q.query(ctx, q.getTodaySensorsSummaryStmt, getTodaySensorsSummary, locationSid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTodaySensorsSummaryRow
	for rows.Next() {
		var i GetTodaySensorsSummaryRow
		if err := rows.Scan(&i.Type, &i.Date, &i.AvgTemperature); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const locationExistBySid = `-- name: LocationExistBySid :one
select count(location_id)
from temp_checker.location
where location_sid = $1
`

func (q *Queries) LocationExistBySid(ctx context.Context, locationSid string) (int64, error) {
	row := q.queryRow(ctx, q.locationExistBySidStmt, locationExistBySid, locationSid)
	var count int64
	err := row.Scan(&count)
	return count, err
}
