name: CD Pipeline
on:
  push:
    tags:
      - 'v*'

permissions:
  contents: read
  packages: read

env:
  TF_WORKING_DIR: 'infra'
  ARM_CLIENT_ID: ${{ secrets.AZ_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZ_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZ_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZ_TENANT_ID }}

  SOURCE_REGISTRY: ghcr.io


jobs:
  config:
    name: Configure Pipeline
    runs-on: ubuntu-22.04
    outputs:
      runner: ubuntu-22.04
    steps:
      - run: echo "Configuring pipeline..."

  infrastructure:
    name: Provision Infrastructure
    environment: PROD
    needs: [config]
    runs-on: ${{ needs.config.outputs.runner }}
    outputs:
      acr_login_server: ${{ steps.tf-output.outputs.acr_login_server }}
      acr_admin_username: ${{ steps.tf-output.outputs.acr_admin_username }}
      acr_admin_password_base64: ${{ steps.tf-output.outputs.acr_admin_password_base64 }}
      vm_public_ip: ${{ steps.tf-output.outputs.vm_public_ip }}
      vm_admin_username: ${{ steps.tf-output.outputs.vm_admin_username }}
      vm_private_key: ${{ steps.tf-output.outputs.vm_private_key }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init \
            -backend-config="resource_group_name=${{vars.TF_AZ_BACK_RG_NAME}}" \
            -backend-config="storage_account_name=${{vars.TF_AZ_BACK_STORAGE_ACC_NAME}}" \
            -backend-config="container_name=${{vars.TF_AZ_CONTAINER_NAME}}" \
            -backend-config="key=${{vars.TF_AZ_BACK_KEY}}"

      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform validate

      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform apply -auto-approve

      - name: Get Terraform Outputs
        id: tf-output
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform refresh
          
          terraform output -json > outputs.json
          
          RAW_PASS=$(jq -r '.acr_admin_password.value' outputs.json)
          
          if [ -z "RAW_PASS" ] || [ "RAW_PASS" == "null" ]; then
            echo "::error::Terraform returned empty password!"
            exit 1
          fi
          
          # acr outputs
          echo "acr_login_server=$(jq -r '.acr_login_server.value' outputs.json)" >> $GITHUB_OUTPUT
          echo "acr_admin_username=$(jq -r '.acr_admin_username.value' outputs.json)" >> $GITHUB_OUTPUT
          
          ENCODED_PASS=$(echo -n "$RAW_PASS" | base64 -w 0)
          
          echo "acr_admin_password_base64=$ENCODED_PASS" >> $GITHUB_OUTPUT
          
          # vm outputs
          echo "vm_public_ip=$(jq -r '.vm_public_ip.value' outputs.json)" >> $GITHUB_OUTPUT
          echo "vm_admin_username=$(jq -r '.vm_admin_username.value' outputs.json)" >> $GITHUB_OUTPUT
          
          # multiline output
          echo "vm_private_key<<EOF" >> $GITHUB_OUTPUT
          jq -r '.vm_private_key.value' outputs.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT


      - name: Upload Terraform Outputs as Artifact
        uses: actions/upload-artifact@v6
        with:
          name: terraform-outputs-json
          path: ${{ env.TF_WORKING_DIR }}/outputs.json
          retention-days: 5

  promote-images:
    name: Promote Images to ACR
    environment: PROD
    runs-on: ${{ needs.config.outputs.runner }}
    needs: [config, infrastructure]
    outputs:
      target_image_tag: ${{ steps.push-image-tag.outputs.target_image_tag }}
    strategy:
      matrix:
        service: [api, web, migrations, seeder, mqtt, reader, crawler, scheduler, grafana, prometheus, loki, promtail]
    steps:
      - name: Downcase REPO
        run: |
          echo "REPO_LC=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

      - name: Docker Login to GHCR (Source)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Test ACR
        run: |
          echo "${{ needs.infrastructure.outputs.acr_login_server }}"
          echo "${{ needs.infrastructure.outputs.acr_admin_username }}"
          echo "${{ needs.infrastructure.outputs.acr_admin_password_base64 }}"
          echo "${{ needs.infrastructure.outputs.vm_private_key }}"
          echo "${{ needs.infrastructure.outputs.vm_public_ip }}"
          echo "${{ needs.infrastructure.outputs.vm_admin_username }}"

      - name: Decode Credentials
        run: |
          ENCODED="${{ needs.infrastructure.outputs.acr_admin_password_base64 }}"
          
          DECODED=$(echo "$ENCODED" | base64 -d)
          
          echo "ACR_PASSWORD=$DECODED" >> $GITHUB_ENV

      - name: Docker Login to ACR (Target)
        uses: docker/login-action@v3
        with:
          registry: ${{ needs.infrastructure.outputs.acr_login_server }}
          username: ${{ needs.infrastructure.outputs.acr_admin_username }}
          password: ${{ env.ACR_PASSWORD }}

      - name: Pull, Retag and Push
        id: push-image-tag
        env:
          TAG_NAME: ${{ github.ref_name }}
        run: |
          echo "target_image_tag=${{ env.TAG_NAME }}" >> $GITHUB_OUTPUT
          
          SOURCE_IMAGE="${{ env.SOURCE_REGISTRY }}/${{ env.REPO_LC }}/${{ matrix.service }}:${{ github.sha }}"
          
          TARGET_IMAGE="${{ needs.infrastructure.outputs.acr_login_server }}/${{ matrix.service }}:${{ env.TAG_NAME }}"
          
          echo "Promoting $SOURCE_IMAGE to $TARGET_IMAGE"
          
          docker pull $SOURCE_IMAGE
          docker tag $SOURCE_IMAGE $TARGET_IMAGE
          docker push $TARGET_IMAGE

  deploy:
    name: Deploy to Production VM
    environment: PROD
    runs-on: ${{ needs.config.outputs.runner }}
    needs: [ config, infrastructure, promote-images ]
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create .env file for Runtime
        run: |
          echo "Generating production .env file..."
          
          # image helpers
          echo "TAG=${{ needs.promote-images.outputs.target_image_tag }}" >> .env
          echo "REGISTRY=${{ needs.infrastructure.outputs.acr_login_server }}" >> .env
          
          # env vars
          echo "ENV=PROD" >> .env
          echo "GO_ENV=PROD" >> .env
          
          # postgres
          echo "DB_USER=${{ secrets.DB_NAME }}" >> .env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
          echo "DB_NAME=${{ secrets.DB_NAME }}" >> .env
          
          # mqtt
          echo "MQTT_BROKER_USERNAME=${{ secrets.MQTT_BROKER_USERNAME }}" >> .env
          echo "MQTT_BROKER_PASSWORD=${{ secrets.MQTT_BROKER_PASSWORD }}" >> .env
          
          # service auth
          echo "AUTH_KEY_VAL=${{ secrets.AUTH_KEY_VAL }}" >> .env
          
          # basic auth
          echo "BASIC_AUTH_USER=${{ secrets.BASIC_AUTH_USER }}" >> .env
          echo "BASIC_AUTH_PASSWORD=${{ secrets.BASIC_AUTH_PASSWORD }}" >> .env
          
          # grafana
          echo "GRAFANA_USER=${{ secrets.GRAFANA_USER }}" >> .env
          echo "GRAFANA_PASSWORD=${{ secrets.GRAFANA_PASSWORD }}" >> .env

      - name: Copy docker-compose to VM
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ needs.infrastructure.outputs.vm_public_ip }}
          username: ${{ needs.infrastructure.outputs.vm_admin_username }}
          key: ${{ needs.infrastructure.outputs.vm_private_key }}
          source: "docker-compose.yml, .env.default, .env"
          target: "/home/${{ needs.infrastructure.outputs.vm_admin_username }}/app"

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1
        env:
          VM_USER: ${{ needs.infrastructure.outputs.vm_admin_username }}
          ACR_USERNAME: ${{ needs.infrastructure.outputs.acr_admin_username }}
          ACR_PASSWORD: ${{ needs.infrastructure.outputs.acr_admin_password }}
          ACR_LOGIN_SERVER: ${{ needs.infrastructure.outputs.acr_login_server }}
        with:
          host: ${{ needs.infrastructure.outputs.vm_public_ip }}
          username: ${{ needs.infrastructure.outputs.vm_admin_username }}
          key: ${{ needs.infrastructure.outputs.vm_private_key }}
          script: |
            cd /home/${{ env.VM_USER }}/app

            docker login ${{ env.ACR_LOGIN_SERVER }} \
              -u ${{ env.ACR_USERNAME }} \
              -p ${{ env.ACR_PASSWORD }}

            docker compose pull
            docker compose up -d --remove-orphans
            docker system prune -f
